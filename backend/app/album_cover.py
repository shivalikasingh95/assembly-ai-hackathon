import replicate
import os
from diffusers import StableDiffusionPipeline
import torch
from PIL.Image import Image
from PIL import PngImagePlugin

REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")

def generate_album_cover_art( config, prompt: str = "a 19th century portrait of a wombat gentleman"):
    """
    This function uses one of the Stable Diffusion models available via Replicate to generate the album cover for a song.
    Args:
        prompt (str): user input that will be given to the model to generate the album/song cover art 
        config (dict): Configuration to be used by the model for genration of song lyrics
    Returns:
        response (str): Link to image output generated by the model hosted by Replicate
    """
    
    model_name = config["replicate_model_name"]
    model_version = config["replicate_model_version"]
    model = replicate.models.get(model_name)
    version = model.versions.get(model_version)
    print(prompt + "album cover art", "prompt")
    response = version.predict(prompt=prompt + "album cover art", num_outputs=4)
    
    return {"output_album": response}

def generate_album_art_using_dreambooth(config: dict, prompt: str):

    pipe = StableDiffusionPipeline.from_pretrained(hf_dreambooth_model_name, 
                torch_dtype=torch.float16).to("cuda")

    num_samples = config['num_samples_for_hf_model']

    # all_images = [] 
    # for _ in range(num_rows):
    images = pipe(prompt, num_images_per_prompt=num_samples, num_inference_steps=25, guidance_scale=9).images
        # all_images.extend(images)
    
    ## encode image to base64
    base64_img = encode_pil_to_base64(images[0])
    
    return {"output_album": base64_img}

def encode_pil_to_base64(pil_image):
    with BytesIO() as output_bytes:

        use_metadata = False
        metadata = PngImagePlugin.PngInfo()
        for key, value in pil_image.info.items():
            if isinstance(key, str) and isinstance(value, str):
                metadata.add_text(key, value)
                use_metadata = True

        pil_image.save(
            output_bytes, "PNG", pnginfo=(metadata if use_metadata else None)
        )
        bytes_data = output_bytes.getvalue()
    base64_str = str(base64.b64encode(bytes_data), "utf-8")
    return "data:image/png;base64," + base64_str